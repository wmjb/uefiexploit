#include "Include/Application.h"
#include <Library/MemoryAllocationLib.h>

UINT32
ArmCallSmcHelper(UINT32 R0, UINT32 R1, UINT32 R2, UINT32 R3)
{
	ARM_SMC_ARGS ArmSmcArgs;

#if DEBUG
	Print(L"ArmCallSmcHelper: >>> {0x%08x, 0x%08x, 0x%08x, 0x%08x}\n", R0, R1, R2, R3);
#endif

	ArmSmcArgs.Arg0 = R0;
	ArmSmcArgs.Arg1 = R1;
	ArmSmcArgs.Arg2 = R2;
	ArmSmcArgs.Arg3 = R3;

	ArmCallSmc(&ArmSmcArgs);

#if DEBUG
	Print(L"ArmCallSmcHelper: <<< {0x%08x, 0x%08x, 0x%08x, 0x%08x}\n", ArmSmcArgs.Arg0, ArmSmcArgs.Arg1, ArmSmcArgs.Arg2, ArmSmcArgs.Arg3);
#endif

	return ArmSmcArgs.Arg0;
}
EFI_STATUS loadPayloadIntoMemory(EFI_PHYSICAL_ADDRESS memoryAddress, short unsigned int fileName[], size_t *fileSize);

void memcpy_usr(void *dest, const void *src, size_t n)
{
	char *src_char = (char *)src;
	char *dest_char = (char *)dest;
	for (int i = 0; i < n; i++)
	{
		dest_char[i] = src_char[i];
	}
}

#define _MEM(addr) *(volatile uint32_t *)(addr)
#define mem_read(addr) _MEM(addr)
#define mem_write(addr, value) _MEM(addr) = value
#define mem_clear(base, value) _R_MEMEG(addr) &= ~value
#define mem_set(base, value) _RE_MEMG(addr) |= value

#define APB_MISC_GP_HIDREV_0 (0x70000804U)

// adopted from kernel code. thanks Leander :)
struct parking_protocol_mailbox
{
	uint32_t cpu_id;
	uint32_t reserved;
	uint64_t entry_point; // keep at 64Bit to keep cpu_mailbox_entry aligned
};

struct cpu_mailbox_entry
{
	struct parking_protocol_mailbox *mailbox;
	uint32_t mailbox_addr;
	uint8_t version;
	uint8_t gic_cpu_id;
};

static struct cpu_mailbox_entry cpu_mailbox_entries[4];

// removed 'unsigned int cpu' from parameter list and changed return type to void
static void acpi_parking_protocol_cpu_init(void)
{
	// Print(L"%s: has been called. Hardcoding MADT table for Surface RT.\r\n", __func__);

	cpu_mailbox_entries[0].gic_cpu_id = 0;
	cpu_mailbox_entries[0].version = 1;
	cpu_mailbox_entries[0].mailbox_addr = 0x82001000;
	cpu_mailbox_entries[0].mailbox = (struct parking_protocol_mailbox *)(0x82001000U);

	cpu_mailbox_entries[1].gic_cpu_id = 1;
	cpu_mailbox_entries[1].version = 1;
	cpu_mailbox_entries[1].mailbox_addr = 0x82002000;
	cpu_mailbox_entries[1].mailbox = (struct parking_protocol_mailbox *)(0x82002000U);

	cpu_mailbox_entries[2].gic_cpu_id = 2;
	cpu_mailbox_entries[2].version = 1;
	cpu_mailbox_entries[2].mailbox_addr = 0x82003000;
	cpu_mailbox_entries[2].mailbox = (struct parking_protocol_mailbox *)(0x82003000U);

	cpu_mailbox_entries[3].gic_cpu_id = 3;
	cpu_mailbox_entries[3].version = 1;
	cpu_mailbox_entries[3].mailbox_addr = 0x82004000;
	cpu_mailbox_entries[3].mailbox = (struct parking_protocol_mailbox *)(0x82004000U);
}

void start_secondary_core(int cpu)
{
	acpi_parking_protocol_cpu_init();

	// Print(L"Let's goooo\r\n");

	// Print(L"mailbox_address: %p\r\n", &cpu_mailbox_entries[cpu].mailbox->cpu_id);

	// Print(L"mailbox_value: %08x\r\n", *((uint32_t*)0x82002000U));



	// Let the secondary core use the payload loaded by UEFI.
	//Print(L"entry_write: %p\r\n", (uint32_t)(&cpu_mailbox_entries[cpu].mailbox->entry_point));
	mem_write((uint32_t)(&cpu_mailbox_entries[1].mailbox->entry_point), 0x93200000U);
	mem_write((uint32_t)(&cpu_mailbox_entries[2].mailbox->entry_point), 0x93300000U);
	mem_write((uint32_t)(&cpu_mailbox_entries[3].mailbox->entry_point), 0x93400000U);
 	
	ArmDataMemoryBarrier();
  	ArmDataSynchronizationBarrier();
	
	mem_write((uint32_t)(&cpu_mailbox_entries[cpu].mailbox->cpu_id), cpu);
 	ArmDataMemoryBarrier();
  	ArmDataSynchronizationBarrier();
	// Interrupt magic.
	// interrupt according to ACPI PP 0x00fe0000
	// reg: 0xf00
	// base: 0x50041000

	//Print(L"now the interrupt\r\n");
	mem_write(0x50041f00U, 0x00fe0000U);
	mem_write(0x50041f00U, 0x00fe0000U);
	mem_write(0x50041f00U, 0x00fe0000U);
	do {
		uint32_t reg = mem_read((uint32_t)(&cpu_mailbox_entries[cpu].mailbox->entry_point));

		reg = mem_read((uint32_t)(&cpu_mailbox_entries[cpu].mailbox->cpu_id));
	

	}while(mem_read((uint32_t)(&cpu_mailbox_entries[cpu].mailbox->entry_point)) != 0);


}

EFI_STATUS PayloadLoaderEntryPoint(EFI_HANDLE ImageHandle, EFI_SYSTEM_TABLE *SystemTable)
{
	EFI_STATUS Status = EFI_SUCCESS;

	unsigned char SmcHandlerString[5];

	SmcHandlerString[0] = 0x02;
	SmcHandlerString[1] = 0x00;
	SmcHandlerString[2] = 0x50;
	SmcHandlerString[3] = 0xe3;
	SmcHandlerString[4] = 0xc8;

	volatile uint32_t *p_chip_id = (uint32_t*)APB_MISC_GP_HIDREV_0;

	uint32_t chip_id = (*p_chip_id >> 8) & 0xff;

	Print(L"CHIP ID = %x \n", chip_id);

	Print(L"Disable Watchdog\n");

	gBS->SetWatchdogTimer(0, 0, 0, NULL);

	Print(L" SetWatchdogTimer\n");

	if (chip_id == 0x30)
	{
		Tegra3ConsoleOutputFixup();
	}

	UINT32 Ret = 0;
	Ret = ArmCallSmcHelper(0x03, 0x09, 0, 0);
	Ret = ArmCallSmcHelper(0x03, 0x05, 0, 0);

	if (chip_id == 0x30)
	{
		Ret = ArmCallSmcHelper(0x03, 0x06, 0x40000000, 0x6001e0e0);
	}
	else if (chip_id == 0x35)
	{
		Ret = ArmCallSmcHelper(0x03, 0x06, 0x40000000, 0x600320e0);
	}
	else
	{
		Status = EFI_ABORTED;
		FinalizeApp();
	}

	gBS->SetMem((VOID *)0x40000000, 32, 0);
	Ret = ArmCallSmcHelper(0x03, 0x03, 0, 0);

	if (chip_id == 0x35)
	{
		ArmDataSynchronizationBarrier();
		ArmInstructionSynchronizationBarrier();
	}

	gBS->Stall(3000000);

	Print(L" ArmCallSmcHelper\n");
	ArmDisableCachesAndMmu();

	if (chip_id == 0x35)
	{
		ArmInvalidateTlb();
		ArmInvalidateDataCache();
		ArmInvalidateInstructionCache();
	}

	UINT32 Something = *((UINT32 *)((VOID *)0x80000000));

	ArmEnableMmu();
	ArmEnableDataCache();
	ArmEnableInstructionCache();

	Print(L"Something at 0x80000000 with exploit: 0x%x\n", Something);
	if (Something == 0xFFFFFFFF)
	{
		Print(L"Something happened and the exploit doesn't work\n");
		Status = EFI_ABORTED;
		FinalizeApp();
	}

	gBS->Stall(1000000);

	size_t fileSize1 = 0;
	Status = loadPayloadIntoMemory((EFI_PHYSICAL_ADDRESS)0x93000000, L"\\payload.bin", &fileSize1);
	size_t fileSizex = 0;
//	Status = loadPayloadIntoMemory((EFI_PHYSICAL_ADDRESS)0x93110000, L"\\payload2.bin", &fileSizex);
//	Status = loadPayloadIntoMemory((EFI_PHYSICAL_ADDRESS)0x93120000, L"\\payload2.bin", &fileSizex);
//	Status = loadPayloadIntoMemory((EFI_PHYSICAL_ADDRESS)0x93130000, L"\\payload2.bin", &fileSizex);
//	Status = loadPayloadIntoMemory((EFI_PHYSICAL_ADDRESS)0x93200000, L"\\smc.bin", &fileSizex);
//	Status = loadPayloadIntoMemory((EFI_PHYSICAL_ADDRESS)0x93300000, L"\\smc.bin", &fileSizex);
//	Status = loadPayloadIntoMemory((EFI_PHYSICAL_ADDRESS)0x93400000, L"\\smc.bin", &fileSizex);

	if (Status != EFI_SUCCESS)
	{
		Print(L"\tFailed at loading payloads!\n");

		FinalizeApp();
	}
	gBS->Stall(1000000);
		//ArmDataSynchronizationBarrier();
	if (chip_id == 0x35)
	{
		Status = loadPayloadIntoMemory((EFI_PHYSICAL_ADDRESS)0x84000000, L"\\u-boot-dtb-s2.bin", &fileSizex);
	}
	else
	{
		Status = loadPayloadIntoMemory((EFI_PHYSICAL_ADDRESS)0x84000000, L"\\u-boot-dtb.bin", &fileSizex);
	}

	if (Status != EFI_SUCCESS)
	{
		Print(L"\tFailed at loading u-boot!\n");
		FinalizeApp();
	}

	Print(L"\tU-boot is now in memory!\n");

	gBS->Stall(2000000);

	Print(L"\n");
	Print(L"Tegra 3/4 UEFI Breaker - CrackTheSurface - jeybee @ openrt.gitbook.io \n");

	if (chip_id == 0x30)
	{
		ArmDisableFiq();
		ArmDisableInterrupts();
	}

	ArmDisableCachesAndMmu();
	if (chip_id == 0x35)
	{
		ArmInvalidateTlb();
		ArmInvalidateDataCache();
		ArmInvalidateInstructionCache();
	}

	void *pTzSmcHandlerString = memmem((void *)0x80000000, 0x200000, SmcHandlerString, sizeof(SmcHandlerString));

	memcpy_usr((void *)(pTzSmcHandlerString), (const void *)0x93000000, (size_t)fileSize1);

	//mem_write(0x82002880U, 0x93110000U);
	//mem_write(0x82003880U, 0x93120000U);
	//mem_write(0x82004880U, 0x93130000U);

	if (chip_id == 0x30)
	{
		ArmDataSynchronizationBarrier();
	}

	ArmEnableMmu();
	ArmEnableDataCache();
	ArmEnableInstructionCache();

	if (chip_id == 0x30)
	{
		ArmEnableFiq();
		ArmEnableInterrupts();
	}



	gBS->Stall(300000);

	Print(L"UEFI SMC ADDR = %x \n", pTzSmcHandlerString);

	gBS->Stall(100000);

	UINTN MemMapSize = 0;
	EFI_MEMORY_DESCRIPTOR *MemMap = 0;
	UINTN MapKey = 0;
	UINTN DesSize = 0;
	UINT32 DesVersion = 0;
Print(L"I just wrote Trustzone and I'm still alive!\r\n");
	gBS->GetMemoryMap(&MemMapSize, MemMap, &MapKey, &DesSize, &DesVersion);

	Status = gBS->ExitBootServices(ImageHandle, MapKey);

	if (EFI_ERROR(Status))
	{
		Print(L"Failed to exit BS\n");
	}



//	Print(L"Starting core 3\r\n");
	//start_secondary_core(3);
	
	//Print(L"Starting core 2\r\n");	
	//start_secondary_core(2);
	
	//Print(L"Starting core 1\r\n");
	//start_secondary_core(1);
	
	Print(L"SMC call\r\n");
	
	gBS->Stall(100000);

	ArmCallSmcHelper(0, 0, 0, 0);

	Print(L"Something went wrong, we shouldn't be here\n");

	FinalizeApp();
	return Status;
}

VOID FinalizeApp(VOID)
{
	Print(L"SOMETHING WENT WRONG. RESETTING DEVICE IN 5 SECONDS\n");

	gBS->Stall(5000000);
	mem_write(0x7000E400, 0x00000010U);
}

EFI_STATUS loadPayloadIntoMemory(EFI_PHYSICAL_ADDRESS memoryAddress, short unsigned int fileName[], size_t *fileSize)
{
	EFI_LOADED_IMAGE *loaded_image = NULL;
	EFI_GUID loaded_image_protocol = LOADED_IMAGE_PROTOCOL;
	EFI_STATUS status;
	EFI_GUID sfspGuid = EFI_SIMPLE_FILE_SYSTEM_PROTOCOL_GUID;
	EFI_SIMPLE_FILE_SYSTEM_PROTOCOL *fs = NULL;

	status = gBS->HandleProtocol(gImageHandle, &loaded_image_protocol, (void **)&loaded_image);

	if (status != EFI_SUCCESS)
	{
		Print(L"Failed at 1st HandleProtocol\n");
		return status;
	}

	status = gBS->HandleProtocol(loaded_image->DeviceHandle, &sfspGuid, (void **)&fs);

	if (status != EFI_SUCCESS)
	{
		Print(L"Failed at 2nd HandleProtocol\n");
		return status;
	}

	EFI_FILE_PROTOCOL *fileProtocol = NULL;

	status = fs->OpenVolume(fs, &fileProtocol);
	EFI_FILE_PROTOCOL *file = NULL;

	if (status != EFI_SUCCESS)
	{
		Print(L"Failed at OpenVolume!\n");
		return status;
	}

	status = fileProtocol->Open(fileProtocol, &file, fileName, EFI_FILE_MODE_READ, EFI_FILE_READ_ONLY | EFI_FILE_HIDDEN | EFI_FILE_SYSTEM);

	if (status != EFI_SUCCESS)
	{
		Print(L"Failed at opening file!\n");
		return status;
	}

	EFI_FILE_INFO *payloadFileInformation = NULL;
	UINTN payloadFileInformationSize = 0;

	status = file->GetInfo(file, &gEfiFileInfoGuid, &payloadFileInformationSize, (VOID *)payloadFileInformation);

	if (status != EFI_SUCCESS && status != EFI_BUFFER_TOO_SMALL)
	{
		Print(L"Failed at getting file info! (1)\n");
		return status;
	}

	status = gBS->AllocatePool(EfiLoaderData, payloadFileInformationSize, (void **)&payloadFileInformation);

	if (status != EFI_SUCCESS)
	{
		Print(L"Failed at allocating pool!\n");
		return status;
	}

	SetMem((VOID *)payloadFileInformation, payloadFileInformationSize, 0xFF);

	status = file->GetInfo(file, &gEfiFileInfoGuid, &payloadFileInformationSize, (VOID *)payloadFileInformation);

	if (status != EFI_SUCCESS)
	{
		Print(L"Failed at getting file info! (2)\n");
		return status;
	}

	EFI_PHYSICAL_ADDRESS payloadFileBuffer = memoryAddress;

	UINTN payloadFileSize = payloadFileInformation->FileSize;

	UINTN Pages = EFI_SIZE_TO_PAGES(payloadFileSize);

	status = gBS->AllocatePages(AllocateAddress, EfiLoaderData, Pages, &payloadFileBuffer);

	if (status != EFI_SUCCESS)
	{
		switch (status)
		{
		case EFI_OUT_OF_RESOURCES:
			break;
		case EFI_INVALID_PARAMETER:
			break;
		case EFI_NOT_FOUND:
			break;
		default:
			break;
		}

		Print(L"Failed at AllocatePages!\n");
		return status;
	}

	SetMem((EFI_PHYSICAL_ADDRESS *)payloadFileBuffer, payloadFileSize, 0xFF);

	status = file->Read(file, &payloadFileSize, (EFI_PHYSICAL_ADDRESS *)payloadFileBuffer);

	if (status != EFI_SUCCESS)
	{
		Print(L"Failed at reading file into memory!\n");
		return status;
	}

	*fileSize = payloadFileSize;

	return EFI_SUCCESS;
}
